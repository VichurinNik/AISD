#pragma once
#pragma once
#include <iostream>
#include <algorithm>
#include <limits>
#include <random>
#include<typeinfo>
using namespace std;
template <typename T>

class Image
{
private:
    size_t _width;    // Ширина изображения
    size_t _height;   // Высота изображения
    T** data;
public:
    Image(size_t width, size_t height, bool random_fill) : _width(width), _height(height)
    {

        if (random_fill)
        {

            std::random_device rd;
            std::mt19937 gen(rd());
            std::uniform_real_distribution<> dis(0, 5000);

            data = new T * [_height];
            for (size_t i = 0; i < _height; ++i)
            {
                data[i] = new T[_width];
                for (size_t j = 0; j < _width; j++)
                {
                    data[i][j] = static_cast<T>(dis(gen));
                }
            }
        }
        else
        {
            data = new T * [_height];
            for (size_t i = 0; i < _height; ++i)
            {
                data[i] = new T[_width];
                for (size_t j = 0; j < _width; j++)
                {
                    data[i][j] = 0;
                }
            }
        }
    }

    Image(size_t width, size_t height) : _width(width), _height(height)
    {
        data = new T * [_height];
        for (size_t i = 0; i < _height; ++i) {
            data[i] = new T[_width];
        }
    }

    Image& operator=(const Image& other)
    {
        if (this == &other)
        {
            return *this;
        }

        for (size_t i = 0; i < _height; ++i) 
        {
            delete[] data[i];
        }
        delete[] data;

        _width = other._width;
        _height = other._height;

        data = new T * [_height];
        for (size_t i = 0; i < _height; ++i) 
        {
            data[i] = new T[_width];
        }

        for (size_t i = 0; i < _height; ++i)
        {
            std::copy(other.data[i], other.data[i] + _width, data[i]);
        }

        return *this;
    }

    /// Конструктор копирования
    Image(const Image& other) : _width(other._width), _height(other._height)
    {
        data = new T * [_width];
        for (size_t i = 0; i < _width; i++) {
            data[i] = new T[_height];
            for (size_t j = 0; j < _height; j++)
            {
                data[i][j] = other.data[i][j];
            }
        }
    }

    // Деструктор
    ~Image() {
        for (size_t i = 0; i < _height; ++i)
        {
            delete[] data[i];
        }
        delete[] data;
    }

    size_t Get_width() const
    {
        return _width;
    }

    size_t  Get_height() const
    {
        return _height;
    }

    // Оператор () для доступа к элементам
    T& operator()(size_t row, size_t col)
    {
        if ((row >= _width || col >= _height) && (row < 0 || col < 0))
        {
            throw std::out_of_range("Индекс вне диапозона");
        }
        return data[row][col];
    }

    const T operator()(size_t row, size_t col) const
    {
        if ((row >= _width || col >= _height) && (row < 0 || col < 0))
        {
            throw std::out_of_range("Индекс вне диапозона");
        }
        return data[row][col];
    }


    // Операторы умножения и сложения для других типов
    template <typename T>
    Image<T>& operator*(const Image<T>& other) {
        if (_width != other._width || _height != other._height)
        {
            throw runtime_error("Dimensions do not match");
        }

        Image<T>* result = new Image<T>(_width, _height);
        for (size_t i = 0; i < _height; ++i)
        {
            for (size_t j = 0; j < _width; ++j)
            {
                (*result)(i, j) = data[i][j] * other(i, j);  // Поэлементное умножение
            }
        }
        return *result;
    }

    Image<T>& operator!()
    {
        Image<T>* result = new Image<T>(_width, _height);
        for (size_t i = 0; i < _height; ++i)
        {
            for (size_t j = 0; j < _width; ++j)
            {
                (*result)(i, j) = !(data[i][j]);
            }
            return *result;
        }
    }

    template <typename T>
    Image<T>& operator+(const Image<T>& other)
    {
        if (_width != other._width || _height != other._height) {
            throw runtime_error("Dimensions do not match");
        }

        Image<T>* result = new Image<T>(_width, _height);
        for (size_t i = 0; i < _height; ++i) {
            for (size_t j = 0; j < _width; ++j) {
                (*result)(i, j) = data[i][j] + other(i, j);  // Поэлементное сложение
            }
        }
        return *result;
    }

    Image<bool>& operator*(const Image<bool>& other) {
        if (_width != other._width || _height != other._height)
        {
            throw runtime_error("Dimensions do not match");
        }

        Image<bool>* result = new Image<bool>(_width, _height);
        for (size_t i = 0; i < _height; ++i)
        {
            for (size_t j = 0; j < _width; ++j)
            {
                (*result)(i, j) = data[i][j] && other(i, j);  // Поэлементное И
            }
        }
        return *result;
    }

    Image<bool>& operator+(const Image<bool>& other)
    {
        if (_width != other._width || _height != other._height)
        {
            throw runtime_error("Dimensions do not match");
        }

        Image<bool>* result = new Image<bool>(_width, _height);
        for (size_t i = 0; i < _height; ++i)
        {
            for (size_t j = 0; j < _width; ++j)
            {
                (*result)(i, j) = data[i][j] || other(i, j);  // Поэлементное ИЛИ
            }
        }
        return *result;
    }

    // Операторы умножения и сложения изображения на константу
    Image<T>& operator*(T value) {
        Image<T>* result = new Image<T>(_width, _height);
        for (size_t i = 0; i < _height; ++i) {
            for (size_t j = 0; j < _width; ++j)
            {
                auto tmp = data[i][j] * value;
                if (tmp > std::numeric_limits<T>::max())
                {
                    (*result)(i, j) = std::numeric_limits<T>::max();
                }
                if (tmp < std::numeric_limits<T>::min())
                {
                    (*result)(i, j) = std::numeric_limits<T>::min();
                }
                else
                (*result)(i, j) = data[i][j] * value;  // Умножение на константу
            }
        }
        return *result;
    }

    Image<T>& operator+(T value) {
        Image<T>* result = new Image<T>(_width, _height);
        for (size_t i = 0; i < _height; ++i)
        {
            for (size_t j = 0; j < _width; ++j)
            {
                auto tmp = data[i][j] + value;
                if (tmp > std::numeric_limits<T>::max())
                {
                    (*result)(i, j) = std::numeric_limits<T>::max();
                }
                if (tmp < std::numeric_limits<T>::min())
                {
                    (*result)(i, j) = std::numeric_limits<T>::min();
                }
                else
                (*result)(i, j) = data[i][j] + value;

               
            }
        }
        return *result;
    }

    //Алгоритм Брезенхема
    void drawFilledCircle(int cx, int cy, int radius, T fillValue)
    {
        int x = 0;
        int y = radius;
        int d = 3 - 2 * radius;

        while (x <= y)
        {
            // Рисуем горизонтальные линии для заполнения внутренней части круга
            drawHorizontalLine(cx - x, cy - y, 2 * x + 1, fillValue);
            drawHorizontalLine(cx - x, cy + y, 2 * x + 1, fillValue);
            drawHorizontalLine(cx - y, cy - x, 2 * y + 1, fillValue);
            drawHorizontalLine(cx - y, cy + x, 2 * y + 1, fillValue);

            if (d < 0)
            {
                d += 4 * x + 6;
            }
            else
            {
                d += 4 * (x - y) + 10;
                y--;
            }
            x++;
        }
    }

    // Функция для рисования горизонтальной линии
    void drawHorizontalLine(int x1, int y, int length, T value)
    {
        for (int x = x1; x < x1 + length; ++x) {
            setPixel(x, y, value);
        }
    }

    // Установка пикселя
    void setPixel(int x, int y, T value) {
        if (x >= 0 && x < _width && y >= 0 && y < _height)
        {
            data[y][x] = value;
        }
    }

    //Вывод
    T PixelImage(const Image img)
    {
        for (size_t i = 0; i < img.Get_height(); ++i) {
            for (size_t j = 0; j < img.Get_width(); ++j)
            {
                if (img(i, j) != 5)
                {
                    cout << ' ';
                }
                else
                {
                    cout << '7';
                }
            }
            cout << endl;
        }
        return 1;
    }
};


template <typename T>
ostream& operator<<(ostream& stream, const Image<T> img)
{
    for (size_t i = 0; i < img.Get_height(); ++i)
    {
        for (size_t j = 0; j < img.Get_width(); ++j)
        {
            stream << img(i, j) << ' ';
        }
        stream << '\n';
    }
    return stream;
};
